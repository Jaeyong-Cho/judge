{
  "information": {
    "program_purpose": {
      "id": "program_purpose",
      "type": "user_note",
      "label": "프로그램 목적",
      "description": "이 프로그램은 어떤 문제를 해결하나요? 주요 목표는 무엇인가요?",
      "example": "PDF에서 데이터를 추출하여 분석을 위한 구조화된 JSON으로 변환"
    },
    "input_type": {
      "id": "input_type",
      "type": "user_note",
      "label": "입력 타입 및 형식",
      "description": "프로그램이 받는 입력의 종류는?",
      "example": "CLI 인자: 파일 경로, 설정 옵션 | API: JSON 페이로드 | 파일: CSV, JSON"
    },
    "output_type": {
      "id": "output_type",
      "type": "user_note",
      "label": "출력 타입 및 형식",
      "description": "프로그램이 생성하는 출력은?",
      "example": "파일: JSON, CSV | 콘솔: 포맷된 텍스트 | API: JSON 응답"
    },
    "function_list": {
      "id": "function_list",
      "type": "code",
      "label": "함수 목록",
      "description": "코드베이스에 정의된 모든 함수",
      "source": "ast_parser"
    },
    "call_graph": {
      "id": "call_graph",
      "type": "code",
      "label": "함수 호출 그래프",
      "description": "어떤 함수가 어떤 함수를 호출하는지",
      "source": "ast_parser"
    },
    "file_structure": {
      "id": "file_structure",
      "type": "code",
      "label": "파일 및 디렉토리 구조",
      "description": "현재 소스 파일의 구조",
      "source": "file_system"
    },
    "design_patterns": {
      "id": "design_patterns",
      "type": "knowledge",
      "label": "적용 가능한 디자인 패턴",
      "description": "이 문제 유형에 적합한 일반적인 패턴",
      "content": {
        "workflow": ["파이프라인", "상태 머신", "이벤트 기반", "요청-응답"],
        "structure": ["계층형", "모듈형", "플러그인 기반"],
        "data_flow": ["스트리밍", "배치", "실시간"]
      }
    },
    "constraints": {
      "id": "constraints",
      "type": "user_note",
      "label": "프로젝트 제약사항",
      "description": "시간, 리소스, 성능 요구사항",
      "example": "일정: 2주 | 팀: 혼자 | 성능: 분당 1000개 파일 처리"
    }
  },
  "judgments": {
    "workflow_design": {
      "id": "workflow_design",
      "name": "프로그램 실행 흐름 설계",
      "description": "프로그램이 시작부터 끝까지 어떻게 실행되어야 하나?",
      "required_information": [
        "program_purpose",
        "input_type",
        "output_type",
        "design_patterns"
      ],
      "guidance": {
        "why": "실행 흐름은 데이터가 프로그램을 통과하는 방식을 결정하며, 유지보수성, 테스트 가능성, 확장성에 영향을 미칩니다.",
        "questions": [
          "프로세스가 선형적인가 아니면 분기가 있는가?",
          "독립적으로 분리할 수 있는 단계들이 있는가?",
          "각 단계에서 오류가 발생하면 어떻게 처리하나?",
          "단계들을 재사용하거나 다르게 조합할 수 있는가?"
        ],
        "examples": [
          "선형 파이프라인: 입력 -> 검증 -> 처리 -> 변환 -> 출력",
          "이벤트 기반: 수신 -> 분배 -> 처리 -> 발행",
          "요청-응답: 수신 -> 라우팅 -> 실행 -> 응답"
        ]
      }
    },
    "function_design": {
      "id": "function_design",
      "name": "함수 구현",
      "description": "어떤 함수들을 구현해야 하며, 어떻게 구조화해야 하나?",
      "required_information": [
        "program_purpose",
        "function_list",
        "call_graph"
      ],
      "guidance": {
        "why": "함수 설계는 코드의 재사용성, 테스트 가능성, 명확성에 영향을 미칩니다.",
        "questions": [
          "각 함수가 단일 책임을 갖고 있는가?",
          "함수가 너무 길지 않은가? (60줄 이상)",
          "반복되는 패턴을 추출할 수 있는가?",
          "추상화 수준이 일관적인가?"
        ],
        "examples": [
          "너무 광범위: process_everything() - 작은 단계로 분리",
          "좋은 예: validate_input(), transform_data(), save_result()",
          "공통 추출: apply_validation_rules(data, rules)"
        ]
      }
    },
    "file_structure": {
      "id": "file_structure",
      "name": "소스 코드 파일 구성",
      "description": "소스 코드를 파일과 디렉토리로 어떻게 나눌 것인가?",
      "required_information": [
        "program_purpose",
        "function_list",
        "file_structure"
      ],
      "guidance": {
        "why": "좋은 파일 구조는 코드 탐색과 유지보수를 쉽게 만듭니다.",
        "questions": [
          "관련된 함수들이 함께 그룹화되어 있는가?",
          "각 파일이 하나의 관심사에 집중하는가?",
          "파일 간 의존성이 명확한가?",
          "코드가 증가할 때 구조가 확장 가능한가?"
        ],
        "examples": [
          "계층별: models/, services/, controllers/",
          "기능별: user/, payment/, notifications/",
          "타입별: validators/, parsers/, formatters/"
        ]
      }
    },
    "data_format": {
      "id": "data_format",
      "name": "데이터 저장 형식",
      "description": "데이터를 어떤 형식으로 저장하거나 유지할 것인가?",
      "required_information": [
        "program_purpose",
        "output_type",
        "constraints"
      ],
      "guidance": {
        "why": "데이터 형식은 상호운용성, 성능, 유지보수성에 영향을 미칩니다.",
        "questions": [
          "누가 이 데이터를 사용하나?",
          "데이터 크기는 얼마나 되나?",
          "사람이 읽을 수 있어야 하나?",
          "어떤 도구들이 이것을 처리해야 하나?"
        ],
        "examples": [
          "JSON: 읽기 쉬움, 널리 지원됨, 중간 크기",
          "바이너리: 빠름, 압축됨, 읽기 어려움",
          "CSV: 간단함, 스프레드시트 친화적, 평면 구조",
          "Parquet: 컬럼형, 압축됨, 분석에 최적화"
        ]
      }
    }
  }
}
